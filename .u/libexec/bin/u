#!/bin/sh
#
# NAME
#     u
#
# DESCRIPTION
#
# DEPENDENCIES
#     - POSIX-compliant shell.
#
# AUTHORS
#     Copyright (c) Robert Zack Jaidyn Norris-Karr <https://github.com/rzjnzk>
#
# NOTES
#     Main Repository: <https://github.com/rzjnzk/u>

# NOTE: If the script-name is already a valid command for the user, for example, `h` being aliased to `history`, an interactive selection could be shown during installation rectify this: option 1, the script is invoked by the script-name as is intended, and the preexisting command is changed to be invoked by a user-provided alternative; option 2, the script is invoked by a user-provided name instead of the script-name as intended, and the preexisting command remains. Information should be printed that explains how to switch to whichever option of the two was not selected at a later time if the user changes their mind.

set -e

# Ensure the `HOME` environment variable is set.
if
    test -z "${HOME}"
then
    printf "%s\n" "${_t_f_red}Error:${_t_reset} The \`HOME\` environment variable is not set." 1>&2

    exit 1
fi

_invocation_path="$(cd -- "$(dirname -- "${0}")" && pwd)"
_basename="$(basename -- "${0}")"
_repository_base__script_name="u"
_repository_base__username="rzjnzk"
_repository_base__name="unix-home-dir"
_repository_base__branch="master"
_repository_base__url_raw="https://raw.githubusercontent.com/rzjnzk/unix-home-dir/master"
_repository_base__url="https://github.com/rzjnzk/unix-home-dir"
_uuid="400a8a66-6b54-4a65-83a3-84f4831ea191"

# TODO: Consider implementing the functionality of and adding this comment: `# WARNING: This line is edited via sed in the `_setup` function. If the variable name is changed here, it must also be changed in the sed pattern.`
_repository_fork__url=""

_t_reset="$(tput sgr0 2> /dev/null)"
_t_f_black="$(tput setaf 0 2> /dev/null)"
_t_f_red="$(tput setaf 1 2> /dev/null)"
_t_f_green="$(tput setaf 2 2> /dev/null)"
_t_f_yellow="$(tput setaf 3 2> /dev/null)"
_t_f_blue="$(tput setaf 4 2> /dev/null)"
_t_f_magenta="$(tput setaf 5 2> /dev/null)"
_t_f_cyan="$(tput setaf 6 2> /dev/null)"
_t_f_white="$(tput setaf 7 2> /dev/null)"
_t_dim="$(tput dim 2> /dev/null)"

_indent="    "

# BEGIN Make tmp directory.

_i=0

_tmpdir="/tmp/${_repository_base__name}.$$"

while
    :
do

    if
        mkdir "${_tmpdir}.$_i" 2> /dev/null
    then
        _tmpdir="${_tmpdir}.$_i"

        break
    fi

    _i="$(expr "${_i}" + 1)"
done

_on_exit()
{
    _exit_code="$?"

    # Remove the temporary directory.
    if
        ! rm -rf "${_tmpdir}"
    then
        printf "%s\n" \
            "${_t_f_red}Error:${_t_reset} Failed to delete the temporary directory: \`${_tmpdir}\`." \
            "${_indent}Please delete the directory manually to avoid leaving unnecessary files: \`rm -rf \"${_tmpdir}\"\`" 1>&2

        exit 1
    fi

    exit "${_exit_code}"
}

trap _on_exit EXIT INT TERM HUP

# END Make tmp directory.

if
    test -n "${U_DIR}"
then
    if
        command -v curl > /dev/null 2>&1
    then
        _source()
        {
            mkdir -p -- "$(dirname -- "${_tmpdir}/.u/${1}")"

            if
                ! curl -sSL "${_repository_base__url_raw}/${1}" -o "${_tmpdir}/.u/${1}"
            then
                _exit_code="$?"

                printf "%s\n" "${_t_f_red}Error:${_t_reset} Failed to source \`${1}\` with \`curl\`." 1>&2

                exit "${_exit_code}"
            fi

            \. "${_tmpdir}/.u/${1}"
        }
    elif
        command -v wget > /dev/null 2>&1
    then
        _source()
        {
            mkdir -p -- "$(dirname -- "${_tmpdir}/.u/${1}")"

            if
                ! wget -qO "${_tmpdir}/.u/${1}" "${_repository_base__url_raw}/${1}"
            then
                _exit_code="$?"

                printf "%s\n" "${_t_f_red}Error:${_t_reset} Failed to source \`${1}\` with \`wget\`." 1>&2

                exit "${_exit_code}"
            fi

            \. "${_tmpdir}/.u/${1}"
        }
    else
        printf "%s\n" "${_t_f_red}Error:${_t_reset} Neither \`curl\` nor \`wget\` is available. Cannot source library files." 1>&2

        exit 1
    fi
else
    _source()
    {
        if
            ! \. "${1}"
        then
            # TODO: Explain to the user that either the file does not exist, or `${U_DIR}` is set even though `u` is not installed, possibly from a previous installation that was not removed correctly.
            printf "%s\n" "${_t_f_red}Error:${_t_reset} Failed to source \`${1}\`." 1>&2

            exit 1
        fi
    }
fi

_ensure_git()
{
    # Attempt to install `git` if not available.
    # TODO: Make `git` installation logic more robust.
    # TODO: Consider automating the download and use of the `pkm` script.
    if
        ! command -v git > /dev/null 2>&1
    then
        if
            command -v apt-get > /dev/null 2>&1 \
            && printf "Attempting to install \`git\` via \`apt-get\` ...\n" \
            && sudo apt-get update \
            && sudo apt-get install -y git
        then
            printf "Successfully installed \`git\` via \`apt-get\`.\n"
        elif
            printf "%s\n" \
                "Failed to install \`git\` via \`apt-get\`." \
                "Attempting to install \`git\` via \`webi.sh\` using \`curl\` ..." \
            && curl -sS "https://webi.sh/git" | sh
        then
            printf "Successfully installed \`git\` via \`webi.sh\`.\n"
        elif
            printf "%s\n" \
                "Failed to install \`git\` via \`webi.sh\` using \`curl\`." \
                "Attempting to install \`git\` via \`webi.sh\` using \`wget\` ..." \
            && wget -qO- "https://webi.sh/git" | sh
        then
            printf "Successfully installed \`git\` via \`webi.sh\`.\n"
        else
            printf "Failed to install \`git\` via \`webi.sh\` using \`wget\`.\n"
            printf "%s\n" "${_t_f_red}Error:${_t_reset} Failed to install \`git\` automatically. If it is already installed, add it to the \`PATH\` environment variable. Otherwise, install it manually, then rerun this command." 1>&2

            return 1
        fi
    fi
}

# Get a scripts description.
# Get the text from the line after the line starting with `# NAME` followed by any amount of spaces, extract only the text after the last occurrence of ` - `.
_get_script_description()
{
    sed -n \
        "
            /^# NAME *$/ \
            {
                n;

                / - / \
                {
                    s/^.* - //p;
                }
            }
        " \
        "${1}" 2> /dev/null
}

# TODO: Consider moving to a printable comment structure at the top of this file, colorisation and dynamic content could be done with tput command substitution evaluated directly in the comment. Consider how to handle help text for other bin scripts when executing via download. Perhapse the a man file can be downloaded in the same transient way to be viewed temporarily, meaning I could do the same for this script if man files support dynamic content. This command substitution could be used in all bin executable scripts for the script name specifically.
_print_help()
{
    printf "${_t_f_cyan}NAME${_t_reset}\n"

    # Print the script name and description.
    printf "%s" "${_indent}${_t_f_green}${_repository_base__script_name}"
    tput dim
    printf "%s\n\n" "- a git-based user and system file management tool that aims to be able to run on any Unix-like environment.${_t_reset}"

    printf "${_t_cyan}COMMANDS${_t_reset}\n"

    printf "%s\n\n" "${_indent}e, -e, --execute"

    # printf "%s\n" \
    #     "${_indent}These subcommands can be invoked directly if \`${_repository_base__name}\` is installed." \
    #     "${_indent}These subcommands cannot be invoked directly if \`${_repository_base__script_name}\` is being executed via download."

    # TODO: Improve english.
    # TODO: Consider describing that 'The following executables' are executable files in `${HOME}/bin`.
    # TODO: Executing via download?
    printf "%s\n" \
        "${_t_f_blue}${_indent}${_indent}The following executables can be invoked directly if \`${_repository_base__name}\` is installed." \
        "${_indent}${_indent}Otherwise, the executable name must be passed as an argument to \`${_repository_base__script_name}\` for execution:" \
        "${_indent}${_indent}${_indent}... transiently from a download stream:" \
        "${_indent}${_indent}${_indent}${_indent}Example: \`curl -sSL \"${_repository_base__url_raw}/bin/${_repository_base__script_name}\" | sh -s -- e EXECUTABLE_NAME_HERE\`." \
        "${_indent}${_indent}${_indent}${_indent}Example: \`wget -qO- \"${_repository_base__url_raw}/bin/${_repository_base__script_name}\" | sh -s -- e EXECUTABLE_NAME_HERE\`." \
        "${_indent}${_indent}${_indent}... or if the script file is removed from the expected directory:" \
        "${_indent}${_indent}${_indent}${_indent}Example: \`curl -sSL \"${_repository_base__url_raw}/bin/${_repository_base__script_name}\" | sh -s -- EXECUTABLE_NAME_HERE\`." \
        "${_indent}${_indent}${_indent}${_indent}Example: \`wget -qO- \"${_repository_base__url_raw}/bin/${_repository_base__script_name}\" | sh -s -- EXECUTABLE_NAME_HERE\`." \
        "${_indent}${_indent}${_indent}All arguments following \`EXECUTABLE_NAME_HERE\` are passed to the executable.${_t_reset}" \
        ""

    # TODO: Handle symlinks more gracefully. Currently there will be duplicate output descriptions with different command names so they could be seperated and not obviously the same script without noticing the description matches.
    for \
        _path in "${HOME}/bin/"*
    do
        _file_name="$(basename -- "${_path}")"

        # Skip listing this script since the description has already been printed.
        if
            test "${_file_name}" = "${_basename}"
        then
            continue
        fi

        # Skip if the path is not an executable file.
        # TODO: Consider `! test -f "${_path}"`.
        if
            test -d "${_path}" \
            || ! test -x "${_path}"
        then
            continue
        fi

        _comment_section_name_description="$(_get_script_description "${_path}")"

        if
            test -n "${_comment_section_name_description}"
        then
            # Print the script name.
            printf "%s" "${_indent}${_indent}$(basename "${_path}")"

            # Print the script description.
            tput dim
            printf " - "
            printf "%s\n" "${_comment_section_name_description}${_t_reset}"
        fi

        # # If the script has a name comment, and it is not blank.
        # if
        #     # test -n "$(printf "%s" "${_comment_section_name}" | sed "/[^ \\t]/p")"
        #     test -n "${_comment_section_name}"
        # then
        #     printf "%s\n" "${_comment_section_name}"
        # else
        #     printf "%s\n" "$(basename "${_script}")"
        # fi
    done

    printf "%s\n" \
        "" \
        "${_t_f_cyan}ORIGINAL AUTHOR" \
        "${_indent}Copyright (c) Robert Zack Jaidyn Norris-Karr <https://github.com/rzjnzk>" \
        "" \
        "REPOSITORY" \
        "${_indent}${_repository_base__url}${_t_reset}" \
        ""
}

# TODO: Consider supporting other remotes, such as GitLab, Bitbucket, and the following.
# TODO: Gitea – A self-hosted lightweight Git service, popular for small teams and open source projects.
# TODO: Gogs – Another self-hosted Git service with a focus on simplicity and minimal resource usage.
# TODO: SourceForge – One of the older hosting platforms, still used for some open source projects.
# TODO: AWS CodeCommit – A managed Git hosting service on AWS.
# TODO: Azure Repos (part of Azure DevOps) – Providing source control for teams using Microsoft’s ecosystem.
# TODO: Test.
# TODO: Handle case where tokens from config files might be malformed, containing the literal characters `\n`, if not already handled.
_init()
{
    # Prompt the user for the `git` host provider.
    # TODO: Support custom host.
    while
        :
    do
        printf "%s\n" \
            "Select the git host provider for your base config:" \
            "" \
            "1. \`github.com\` (recommended) (default)." \
            "0. Custom."

        _user_input_host_provider=""

        read -r _user_input_host_provider

        if
            test -z "${_user_input_host_provider}" \
            || test -n "$(printf "%s" "${_user_input_credentials}" | sed -n "/^[0-9][0-9]*$/p")"
        then
            break
        else
            printf "%s\n\n" "${_t_f_red}Error:${_t_reset} Invalid input. Please enter an integer." 1>&2
        fi
    done

    # Handle forking the base repo for if GitHub was selected as the host provider.
    # TODO: Support `${HOME}/.git-credentials` if it is a typical credential directory.
    if
        test -z "${_user_input_host_provider}" \
        || test "${_user_input_host_provider}" = 1
    then
        _github_credentials__get_credential="$(
            printf "%s\n" "protocol=https" "host=github.com" \
            | git credential fill \
            | sed -n \
                "
                    /^username=/ \
                    {
                        s/^username=//;
                        h;
                        d;
                    }

                    /^password=/ \
                    {
                        s/^password=//;
                        H;
                        g;
                        s/\n/,/;
                        p;
                        q;
                    }
                "
        )"

        _github_credentials__netrc="$(
            if
                test -f "${HOME}/.netrc"
            then
                # TODO: There might be tab characters after a key such as `machine`, but the most portable way would be to hardcode a literal tab character.
                sed -n \
                "
                    /^ *machine  *api\.github\.com$/ \
                    {
                        :loop;
                        n;
                        /^ *machine  */q;

                        /^ *login/ \
                        {
                            s/^ *login  *//;
                            h;
                        }

                        /^password/ \
                        {
                            s/^ *password  *//;
                            H;
                            g;
                            s/\n/,/;
                            p;
                            q;
                        }

                        b loop;
                    }
                " \
                "${HOME}/.netrc"
            fi
        )"

        # TODO: Support tab indents. The most portable way would be to hardcode a literal tab character.
        _github_credentials__gh="$(
            _user_values_indent="$(
                sed -n \
                "
                    /^github.com:/ \
                    {
                        n;
                        s/^\(  *\).*$/\1/p;
                        q;
                    }
                " \
                "${HOME}/.config/gh/hosts.yml"
            )"

            sed -n \
                "
                    /^github\.com:/,/^[^ ]/ \
                    {

                        /^${_user_values_indent}users:/ \
                        {
                            :users;
                            n;

                            /^${_user_values_indent}[^ ]/q;

                            # Assume the line is the username.
                            /^${_user_values_indent}${_user_values_indent}[^:]*:/ \
                            {
                                # Extract the username.
                                s/^${_user_values_indent}${_user_values_indent}\([^:]*\): */\1/;

                                # Append the username to the hold space.
                                h;

                                :token;

                                # Read the next line, which should contain the token.
                                n;

                                # Look for the \`oauth_token\` line.
                                /^${_user_values_indent}${_user_values_indent}${_user_values_indent}oauth_token:[ ]*/ \
                                {
                                    # Extract the token.
                                    s/^${_user_values_indent}${_user_values_indent}${_user_values_indent}oauth_token:[ ]*//;

                                    # Append the token to the hold space, which now contains \`username\noauth_token\`.
                                    H;

                                    # Copy the hold space into the pattern space.
                                    g;

                                    # Replace the newline with a comma.
                                    s/\(.*\)\n\(.*\)/\1,\2/;

                                    p;

                                    # Loop to process remaining lines in the users block.
                                    b users;
                                }

                                b token;
                            }
                        }
                    }
                " \
                "${HOME}/.config/gh/hosts.yml"
        )"

        # Prompt the user to select a specific retrieved set of credentials or manual input.
        if
            test -n "${_github_credentials__get_credential}" \
            || test -n "${_github_credentials__netrc}" \
            || test -n "${_github_credentials__gh}"
        then
            _print_selection_credential_source()
            {
                for \
                    _line in ${1}
                do
                    _count_options="$(expr "${_count_options}" + 1)"

                    _username="$(printf "%s" "${_line}" | sed -n "s/^\(.*\),..*$/\1/p")"

                    if
                        test -n "${_username}"
                    then
                        printf "%s\n" "${_count_options}. ${_username} (source: \`${2}\`)."
                    fi
                done
            }

            while
                :
            do
                # TODO: Explain that multiple users of the same name are shown incase they have different PAT's, and one might be preferable for the user over another.
                printf "%s\n" \
                    "Found configured \`github.com\` credentials." \
                    "" \
                    "Select credential source:" \
                    ""

                __count_options=0

                _print_selection_credential_source "${_github_credentials__get_credential}" \
                    "git credential fill"

                _print_selection_credential_source "${_github_credentials__netrc}" \
                    "~/.netrc"

                _print_selection_credential_source "${_github_credentials__gh}" \
                    "~/.config/gh/hosts.yml"

                _count_options=""

                printf "0. Enter manually (default).\n"

                _token_map=$(
                    printf "%s\n" \
                        "${_github_credentials__get_credential}" \
                        "${_github_credentials__netrc}" \
                        "${_github_credentials__gh}"
                )

                printf "\n> "

                read -r _user_input_credentials

                if
                    test -z "${_user_input_credentials}" \
                    || test -n "$(printf "%s" "${_user_input_credentials}" | sed -n "/^[0-9][0-9]*$/p")"
                then
                    _user_input_credentials=0

                    break
                else
                    printf "%s\n\n" "${_t_f_red}Error:${_t_reset} Invalid input. Please enter an integer." 1>&2
                fi
            done
        else
            _user_input_credentials="0"
        fi

        # If the user selected manual input, prompt for the Personal Access Token.
        if
            test "${_user_input_credentials}" = 0
        then
            # TODO: Support browser redirect authentication in a similar way to `gh auth login`.

            printf "%s\n" \
                "${_t_f_blue}Hint:${_t_reset} Personal Access Token's can be created here: \`https://github.com/settings/tokens\`." \
                "${_t_f_blue}Hint:${_t_reset} The entered Personal Access Token must at least have the \`public_repo\` scope." \
                "" \
                "Enter token: "

            read -r _token

            # TODO: Verify token login and loop back to token entry if unable to login.

            printf "\n"
        else
            _username="$(
                printf "%s\n" "${_token_map}" | sed -n \
                    "
                        ${_user_input_credentials} \
                        {
                            s/^\(..*\),..*$/\1/p;
                        }
                    "
            )"

            _token="$(
                printf "%s\n" "${_token_map}" | sed -n \
                    "
                        ${_user_input_credentials} \
                        {
                            s/^..*,\(..*\)$/\1/p;
                        }
                    "
            )"

            # TODO: Verify token login and loop back to 'Select credential source' if unable to login.
        fi

        # TODO: COnsider storing credentials securely.

        printf "%s\n" \
            "Enter core repository name (default: \`${_repository_base__name}\`)." \
            "" \
            "> "

        read -r _user_input_fork_name

        printf "\n"

        if
            test -z "${_user_input_fork_name}"
        then
            _user_input_fork_name="${_repository_base__name}"
        fi

        # TODO: Validate repository name characters, and check if the repository already exists.

        # TODO: Prompt for visibility, possibly including the third type.
        # TODO: Consider other repository configuration prompts.

        _fork_post_url="https://api.github.com/repos/${_repository_base__username}/${_repository_base__name}/forks"

        # Fork the base repository.
        # TODO: Check for one of these command before getting this far, and attempt to install one in a similar way as is done with git. This should be done with other core commands with no graceful fallbacks.
        if
            command -v curl > /dev/null 2>&1
        then
            _fork_url="$(curl -s \
                -X POST \
                -H "Authorization: token ${_token}" \
                -H "Accept: application/vnd.github+json" \
                "${_fork_post_url}" \
                -d "{\"name\":\"${_user_input_fork_name}\"}" \
                | sed -n \
                    "
                        /\"clone_url\"/ \
                        {
                            s/^.*\"clone_url\"[ ]*:[ ]*\"\([^\"]*\)\".*$/\1/p;
                        }
                    "
            )"
        elif
            command -v wget > /dev/null 2>&1
        then
            _fork_url="$(wget -qO- \
                --method=POST \
                --header="Authorization: token ${_token}" \
                --header="Accept: application/vnd.github+json" \
                --header="Content-Type: application/json" \
                --body-data="{\"name\":\"${_user_input_fork_name}\"}" \
                "${_fork_post_url}" \
                | sed -n \
                    "
                        /\"clone_url\"/ \
                        {
                            s/^.*\"clone_url\"[ ]*:[ ]*\"\([^\"]*\)\".*$/\1/p;
                        }
                    "
            )"
        else
            printf "%s\n" "${_t_f_red}Error:${_t_reset} Neither \`curl\` nor \`wget\` are available. Please install one of them and try again." 1>&2

            return 1
        fi

        # Verify that a fork URL was received.
        if
            test -z "$(printf "%s" "${_fork_url}" | sed -n "/^https:\/\/github\.com\/.*\/${_user_input_fork_name}\.git$/p")"
        then
            _repository_fork__url="${_fork_url}"
            _fork_url=""

            printf "%s\n" \
                "Success: Core repository created." \
                "Remote URL: \`${_repository_fork__url}\`." \
                ""
        else
            printf "%s\n" \
                "${_t_f_red}Error:${_t_reset} Fork URL does not match expected pattern." \
                "${_indent}1. Check whether the repository was created on GitHub. If it was, delete it." \
                "${_indent}3. Inspect the output of previous commands." \
                "${_indent}2. Check whether the Personal Access Token is valid and has the \`public_repo\` scope." \
                1>&2
                # "${_indent}4. Check whether the repository name is correct." \
                # "${_indent}5. Check whether the repository already exists." \
                # "${_indent}6. Check whether the repository is private and the Personal Access Token has the \`repo\` scope." \
            return 1
        fi

        # TODO: Update the forks `README.md` with the correct installation command. Update any other relevent commands and info.
        # TODO: Update the forks `u` script to include the URL of the forked repository.
        # TODO: Update any `state/` files.

        # # Variables
        # GITHUB_TOKEN="your_personal_access_token"
        # REPO_OWNER="your_username_or_org"
        # REPO_NAME="your_repo_name"
        # FILE_PATH="path/to/file.txt"
        # COMMIT_MESSAGE="Update file via script"
        # NEW_CONTENT="This is the new content of the file."

        # # Encode the new content in base64
        # ENCODED_CONTENT=$(printf "%s" "$NEW_CONTENT" | base64)

        # # Get the current file's SHA
        # FILE_SHA=$(curl -s \
        #     -H "Authorization: token $GITHUB_TOKEN" \
        #     -H "Accept: application/vnd.github+json" \
        #     "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/contents/$FILE_PATH" \
        #     | sed -n 's/.*"sha": "\([^"]*\)".*/\1/p')

        # # Update the file
        # curl -s \
        #     -X PUT \
        #     -H "Authorization: token $GITHUB_TOKEN" \
        #     -H "Accept: application/vnd.github+json" \
        #     -d "{
        #         \"message\": \"$COMMIT_MESSAGE\",
        #         \"content\": \"$ENCODED_CONTENT\",
        #         \"sha\": \"$FILE_SHA\"
        #     }" \
        #     "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/contents/$FILE_PATH"

        # TODO: Explain next steps, including local installation, and general utilization.
    elif
        test "${_user_input_host_provider}" = 0
    then
        # TODO: Implement custom `git` host provider.

        printf "%s\n" "${_t_f_red}Error:${_t_reset} Support for custom \`git\` host providers has yet to be added." 1>&2

        return 1
    fi

    # Ask the user if they want to install the tool for the current user.
    # TODO: Mention the remotes to be installed, those that are default if no args passed, or show the args. Consider the automatic cancellation logic if there are any args that dont match remotes. Perhapse do not even accept args and get the user to run the install command later.
    while
        :
    do
        printf "%s\n" "Install for the current user? (Y/n) "

        read -r _user_input

        printf "\n"

        if
            test -z "${_user_input}" \
            || test "${_user_input}" = "y" \
            || test "${_user_input}" = "Y"
        then
            _install "${@}"
        elif
            test "${_user_input}" = "n" \
            || test "${_user_input}" = "N"
        then
            printf "%s\n" \
                "Installation cancelled." \
                "${_t_f_blue}Hint:${_t_reset} Installation instructions can be viewed in your repositories \`README.md\` file: \`${_fork_url}\`."
        else
            printf "%s\n\n" "${_t_f_red}Error:${_t_reset} Invalid input. Please enter \`y\` or \`n\`." 1>&2
        fi
    done
}

# TODO: Avoid race conditions with `flock`, else `lockf`, else, `.lock` file convention.
_shell_startup_files_remove_snippet()
{
    for \
        _file_name in \
            ".profile" \
            ".bashrc"
    do
        # shellcheck disable=SC2312
        if
            test -z \
                "$(
                    sed -n \
                    "
                        /^# >>> ${_uuid} >>> */ \
                        {
                            :loop;
                            n;

                            /^# <<< ${_uuid} <<< */p;

                            b loop;
                        }
                    " \
                    "${HOME}/${_file_name}"
                )"
        then
            sed \
                "
                    /^# >>> ${_uuid} >>>/,
                    /^# <<< ${_uuid} <<</ \
                    {
                        d;
                    } \
                " \
                "${HOME}/${_file_name}" \
                > "${_tmpdir}/${_file_name}" \
                && mv -f "${_tmpdir}/${_file_name}" "${HOME}/${_file_name}"
        fi
    done
}

_get_remote_conf_values()
{
    if
        test -f "${U_DIR}/local/config/u/remotes/${1}/.conf"
    then
        _remote_conf_file="${U_DIR}/local/config/u/remotes/${1}/.conf"
    elif
        test -f "${U_DIR}/config/u/remotes/${1}/.conf"
    then
        _remote_conf_file="${U_DIR}/config/u/remotes/${1}/.conf"
    else
        printf "%s\n\n" "${_t_f_red}Error:${_t_reset} Could not read remote configuration file for \`${1}\`." 1>&2

        return 1
    fi

    eval \
        "
            # Set default config values to use if not set in the configuration file.
            ${2}dir=\"\"
            ${2}is_use_git=\"true\"
            ${2}is_overlay_files=\"false\"
            ${2}visibility=\"public\"
            ${2}is_encrypted=\"false\"
            ${2}commit_hash=\"\"
            ${2}pull_remote=\"\"
            ${2}pull_remote_branch=\"master\"
            ${2}pull_local_branch=\"master\"
            ${2}push_remote=\"\"
            ${2}push_remote_branch=\"master\"
            ${2}push_local_branch=\"master\"

            # Read the configuration file and set the variables.
            $(
                # shellcheck disable=SC2312
                sed \
                    "
                        s/^ *#.*$//;
                        /^ *$/d;
                        s/^ *\([^=][^=]*\)=/${2}\1=/;
                        s/ *= */=/;
                        s/ *$//;
                    " \
                    "${_remote_conf_file}"
            )
        "
}

_set_remote_names()
{
    # set -- $(
    #     for \
    #         _arg in "${@}"
    #     do
    #         if
    #             test -n "${_arg}"
    #         then
    #             printf "%s\n" "${_arg}"
    #         fi
    #     done
    # )

    if
        test "${#}" -eq 0
    then
        set -- "default"
    fi

    _invalid_remote_names=""

    # Store invalid remotes to print next.
    # INFO: Store arguments that do not correspond to a group or remote configuration in `config` or `local/config`.
    for \
        _arg in "${@}"
    do
        if
            ! test "${_arg}" = "-a" \
            && ! test "${_arg}" = "--all" \
            && ! test -e "${U_DIR}/config/u/remotes/${_arg}" \
            && ! test -e "${U_DIR}/local/config/u/remotes/${_arg}"
        then
            _invalid_remote_names="${_invalid_remote_names}$(printf "%s\n" "${_indent}${_arg}")"
        fi
    done

    # If there are any invalid remotes, print an error message and exit.
    if
        test -n "${_invalid_remote_names}"
    then
        printf "%s\n" \
            "" \
            "${_t_f_red}Error:${_t_reset} The following remotes or groups do not exist." \
            "" \
            "${_t_f_red}${_invalid_remote_names}${_t_reset}" \
            "" \
            "${_t_dim}Note: Remote and remote-group configuration locations:" \
            "${_indent}\`\${U_DIR}/config/u/remotes/\` (git-tracked)." \
            "${_indent}\`\${U_DIR}/local/config/u/remotes/\` (local).${_t_reset}" \
            "" \
            "Available remotes and groups:" \
            "" \
            "${_t_f_blue}$(
                ls -1 "${U_DIR}/config/u/remotes/" | sed "s/\(.*\)/${_indent}\1/"
                ls -1 "${U_DIR}/local/config/u/remotes/" | sed "s/\(.*\)/${_indent}\1/"
            )${_t_reset}" \
            1>&2

        return 1
    fi

    # TODO: Escape `sed` special characters in `_remote_name`.

    _remote_names=""

    for \
        _arg in "${@}"
    do
        if
            test "${_arg}" = "-a" \
            || test "${_arg}" = "--all"
        then
            set --

            for \
                _remote_dir in "${U_DIR}/config/u/remotes" "${U_DIR}/local/config/u/remotes"
            do
                if
                    cd "${_remote_dir}" 2> /dev/null
                then
                    for \
                        _remote_name in *
                    do
                        # shellcheck disable=SC2312
                        if
                            test -d "${_remote_name}" \
                            && test -z "$(printf "%s\n" "${_remote_names}" | sed -n "/^${_remote_name}$/p" 2> /dev/null)"
                        then
                            _remote_names="$(printf "%s\n" "${_remote_names}" "${_remote_name}")"
                        fi
                    done
                fi
            done

            break
        fi
    done

    _add_remotes_deduplicate()
    {
        for \
            _remote_name in ${1}
        do
            # Skip if `_remote_name` is already in `_remote_names`.
            # shellcheck disable=SC2312
            if
                test -z "$(printf "%s\n" "${_remote_names}" | sed -n "/^${_remote_name}$/p" 2> /dev/null)"
            then
                _remote_names="$(printf "%s\n" "${_remote_names}" "${_remote_name}")"
            fi
        done
    }

    for \
        _arg in "${@}"
    do
        if
            test -z "${_arg}"
        then
            continue
        fi

        if
            test -f "${U_DIR}/local/config/u/remotes/${_arg}"
        then
            _add_remotes_deduplicate \
                "$(
                    # shellcheck disable=SC2312
                    sed \
                        "/^ *$/d; /^ *#/d; s/^ *//; s/ *$//" \
                        "${U_DIR}/local/config/u/remotes/${_arg}"
                )"
        elif
            test -d "${U_DIR}/local/config/u/remotes/${_arg}"
        then
            _add_remotes_deduplicate "$(printf "%s\n" "${_arg}")"
        elif
            test -f "${U_DIR}/config/u/remotes/${_arg}"
        then
            _add_remotes_deduplicate \
                "$(
                    # shellcheck disable=SC2312
                    sed \
                        "/^ *$/d; /^ *#/d; s/^ *//; s/ *$//" \
                        "${U_DIR}/config/u/remotes/${_arg}"
                )"
        elif
            test -d "${U_DIR}/config/u/remotes/${_arg}"
        then
            _add_remotes_deduplicate "$(printf "%s\n" "${_arg}")"
        fi
    done

    # Validate remote configuration files.
    # TODO: Make more robust.
    for \
        _remote_name in $(printf "%s\n" "${_remote_names}")
    do
        _get_remote_conf_values "${_remote_name}" "_remote_conf_value__"

        # dir = "${U_DIR}/opt/custom_name_here"
        # #is_use_git = true
        # #is_overlay_files = false
        # #visibility = public
        # #is_encrypted = false
        # commit_hash = a8f4e2c1d9b7e6f3c2a1b0d4e5f6a7b8c9d0e1f2
        # #pull_url = https://github.com/USER_NAME_HERE/REPO_NAME_HERE
        # pull_branch_remote =
        # pull_branch_local =
        # #push_url = https://github.com/USER_NAME_HERE/REPO_NAME_HERE
        # push_branch_remote =
        # push_branch_local =

        _err_string=""

        # Validate boolean values.
        for \
            _var_name in \
                _remote_conf_value__is_use_git \
                _remote_conf_value__is_overlay_files \
                _remote_conf_value__is_encrypted
        do
            eval "_val=\"\${${_var_name}}\""

            if
                test "${_val}" != true \
                && test "${_val}" != false
            then
                _err_string="${_err_string}$(
                        printf "%s\n" \
                            "${_t_f_red}Error:${_t_reset} Invalid value for \`${_var_name}\` in remote configuration file: \`${_remote_conf_file}\`. Value must be \`true\` or \`false\`."
                    )"
            fi
        done

        # Validate visibility.
        if
            test "${_remote_conf_value__visibility}" != "public" \
            && test "${_remote_conf_value__visibility}" != "private" \
            && test "${_remote_conf_value__visibility}" != "internal"
        then
            _err_string="${_err_string}$(
                printf "%s\n" \
                    "${_t_f_red}Error:${_t_reset} Invalid value for \`_remote_conf_value__visibility\` in remote configuration file: \`${_remote_conf_file}\`. Value must be \`public\`, \`private\`, or \`internal\`."
            )"
        fi

        # Validate commit hash.
        if
            test -n "$(printf "%s" "${_remote_conf_value__commit_hash}" | sed -n "/^[0-9a-f]\{4,40\}$/p")"
        then
            _err_string="${_err_string}$(
                printf "%s\n" \
                    "${_t_f_red}Error:${_t_reset} Invalid value for \`_remote_conf_value__commit_hash\` in remote configuration file: \`${_remote_conf_file}\`. Value must be a valid commit hash."
            )"
        fi

        # Validate URLs.
        for \
            _var_name in \
                _remote_conf_value__pull_remote \
                _remote_conf_value__push_remote
        do
            eval "_var=\"\${${_var_name}}\""

            if
                test -n "${_var}" \
                && test -z "$(printf "%s" "${_var}" | sed -n "/^https:\/\//p; /^http:\/\//p;")"
            then
                _err_string="${_err_string}$(
                    printf "%s\n" \
                        "${_t_f_red}Error:${_t_reset} Invalid value for \`${_var_name}\` in remote configuration file: \`${_remote_conf_file}\`. Value must be a URL."
                )"
            fi
        done
    done

    # If there were any validation errors, print them and return a non-zero exit code.
    if
        test -n "${_err_string}"
    then
        printf "%s\n" "${_err_string}" 1>&2

        return 1
    fi
}

_install()
{
    # Install `u` if snippet is not present in `${HOME}/.profile`, indicating `u` is not installed.
    if
        test -z \
            "$(
                # shellcheck disable=SC2312
                sed -n \
                "
                    /^# >>> ${_uuid} >>> */ \
                    {
                        :loop;
                        n;

                        /^# <<< ${_uuid} <<< */p;

                        b loop;
                    }
                " \
                "${HOME}/.profile"
            )"
    then
        printf "%s\n\n" "Installing the base system ..."

        # Set the default installation directory.
        U_DIR="${HOME}/.${_repository_base__script_name}"

        # If `U_DIR` exists, prompt the user for a resolution.
        # TODO: Add warning that the path might not belong to this tool.
        # TODO: Explain which options to select for specific situations.
        if
            test -e "${U_DIR}"
        then
            while
                :
            do
                # TODO: Make prompt more readable.
                printf "%s\n" \
                    "The installation path already exists: \`${U_DIR}\`." \
                    "" \
                    "Select an option to resolve the name conflict with the existing file or directory at this path." \
                    "" \
                    "1. Create a numbered backup before replacing. Format: \`${U_DIR}.~\${_number}~\`. (default)." \
                    "2. Delete and replace." \
                    "3. Provide a custom name for the installation directory (recommended if the existing path is not part of this tool and cannot be moved or deleted)." \
                    "" \
                    "0. Abort installation." \
                    "" \
                    "> "

                read -r _user_input_name_conflict_resolution

                printf "\n"

                if
                    test -z "${_user_input_name_conflict_resolution}" \
                    || test "${_user_input_name_conflict_resolution}" = "1"
                then
                    _number=1

                    while
                        test -e "${U_DIR}.~${_number}~"
                    do
                        _number="$(expr "${_number}" + 1)"
                    done

                    mv -- "${U_DIR}" "${U_DIR}.~${_number}~"

                    printf "%s\n\n" "Moved \`${U_DIR}\` to \`${U_DIR}.~${_number}~\`."

                    _number=""

                    break
                elif
                    test "${_user_input_name_conflict_resolution}" = "2"
                then
                    rm -rf -- "${U_DIR}"

                    printf "%s\n\n" "Deleted \`${U_DIR}\`."

                    break
                elif
                    test "${_user_input_name_conflict_resolution}" = "3"
                then
                    while
                        :
                    do
                        printf "%s\n" \
                            "Enter a custom name for the installation directory." \
                            "" \
                            "> "

                        read -r _user_input_custom_u_dir

                        if
                            test -z "${_user_input_custom_u_dir}"
                        then
                            printf "%s\n\n" "${_t_f_red}Error:${_t_reset} Custom installation directory name cannot be empty." 1>&2
                        elif
                            test -e "${HOME}/${_user_input_custom_u_dir}"
                        then
                            printf "%s\n\n" "${_t_f_red}Error:${_t_reset} Path already exists: \`${HOME}/${_user_input_custom_u_dir}\`." 1>&2
                        else
                            mkdir -p -- "${HOME}/${_user_input_custom_u_dir}"

                            if
                                test -d "${HOME}/${_user_input_custom_u_dir}"
                            then
                                printf "%s\n\n" "Created directory: \`${HOME}/${_user_input_custom_u_dir}\`."

                                U_DIR="${HOME}/${_user_input_custom_u_dir}"

                                break
                            else
                                printf "%s\n\n" \
                                    "${_t_f_red}Error:${_t_reset} Failed to create directory: \`${HOME}/${_user_input_custom_u_dir}\`." 1>&2
                            fi
                        fi
                    done

                    break
                elif
                    test "${_user_input_name_conflict_resolution}" = 0
                then
                    printf "%s\n\n" "Base system installation aborted."

                    return 0
                else
                    printf "%s\n\n" "Invalid input. Please enter an integer." 1>&2
                fi
            done
        fi

        # TODO: `_repository_fork__url` is only defined if `_install()` was called from `_init()`. Ensure this is defined by a wrapper script to `u` in the users fork, or if the full `u` script is copied to the users fork, ensure there is some other method: either still a wrapper; or substitute the value at the top of the file in the users fork during the init process. If I do do a wrapper script, then that also must be used by the user when `u` is installed.
        git clone --depth 1 "${_repository_fork__url}" "${U_DIR}"

        printf "%s\n" \
            "Cloned \`${_repository_fork__url}\` to \`${U_DIR}\`."

        # TODO: Handle cloning any files from the base repo here if all functional files are not copied to the fork, the fork being only the bare minimum.

        mkdir -p \
            "${U_DIR}/opt" \
            "${U_DIR}/local" \
            "${U_DIR}/local/config" \
            "${U_DIR}/local/bin"

        # TODO: Consider checking for script name collision for any scripts in `${U_DIR}/libexec/bin` before sourcing shell startup files. Scripts cloned or downloaded to the `${U_DIR}/opt` dir can be checked when they are downloaded or cloned, so this logic should be abstracted to a function.

        # TODO: Install any files from the base repo that are required and not in the fork.
        # Append snippet to shell startup files.
        for \
            _file_name in \
                "profile" \
                "bashrc"
        do
            _shell_startup_files_remove_snippet

            _shell_startup_file_snippet="$(
                printf "%s\n" \
                    "" \
                    "# >>> ${_uuid} >>>" \
                    "# WARNING: DO NOT EDIT THESE COMMENTS OR LINES." \
                    "export U_DIR=\"\${U_DIR}\"" \
                    "# shellcheck source=/home/user/.u/etc/profile" \
                    "\\. \"\${U_DIR}/etc/${_file_name}\"" \
                    "# <<< ${_uuid} <<<"
            )"

            printf "%s\n" \
                "Adding the following snippet to \`${HOME}/.${_file_name}\`:" \
                "" \
                "${_shell_startup_file_snippet}" \
                ""

            printf "%s\n" "${_shell_startup_file_snippet}" >> "${HOME}/.${_file_name}"

            printf "%s\n" \
                "+ \\. \`${HOME}/.${_file_name}\`"

            # shellcheck disable=SC1090
            \. "${HOME}/.${_file_name}"
        done

        printf "%s\n\n" "Success: Base system installation complete."
    fi

    _set_remote_names "${@}"

    # dir = "${U_DIR}/opt/custom_name_here"
    # is_use_git = true
    # is_overlay_files = false
    # visibility = public
    # is_encrypted = false
    # commit_hash = a8f4e2c1d9b7e6f3c2a1b0d4e5f6a7b8c9d0e1f2
    # pull_url = http://github.com/USER_NAME_HERE/REPO_NAME_HERE
    # pull_branch_remote =
    # pull_branch_local =
    # push_url = http://github.com/USER_NAME_HERE/REPO_NAME_HERE
    # push_branch_remote =
    # push_branch_local =

    # target_dir = "${U_DIR}/opt/custom_name_here"
    # # Options: `git_direct_clone`, `git_insert`, `git_insert_multi`, `get`
    # mode =
    # visibility = public
    # is_encrypted = false
    # commit_hash = a8f4e2c1d9b7e6f3c2a1b0d4e5f6a7b8c9d0e1f2
    # remote = https://github.com/USER_NAME_HERE/REPO_NAME_HERE
    # branch = master

    # shellcheck disable=SC2154
    for \
        _remote_name in $(printf "%s\n" "${_remote_names}")
    do
        _get_remote_conf_values "${_remote_name}" "_remote_conf_value__"

        if
            test "${_remote_conf_value__is_use_git}" = true
        then
            # Create the target directory if it doesn't exist.
            mkdir -p -- "${_remote_conf_value__target_dir}"

            # Change into the target directory (all further git commands operate here).
            cd "${_remote_conf_value__target_dir}"

            if
                ! test -d "${_remote_conf_value__target_dir}/.git"
            then
                git init
            fi

            git remote add "${_remote_name}" "${_remote_conf_value__remote}"

            `git`, `git_multi_track`, `get`

            # Fetch the specified remote branch from 'origin-pull' and update/create the local branch.
            # This does NOT check out the branch or any files yet.
            git fetch "${_remote_name}" "${_remote_conf_value__pull__remote_branch}:${_remote_conf_value__pull__local_branch}"

            # If a specific commit hash is provided ...
            if
                test -n "${_remote_conf_value__commit_hash}"
            then
                # ... create and check out a new local branch at that specific commit.
                git checkout -b "${_remote_conf_value__pull__local_branch}" "${_remote_conf_value__commit_hash}"
            else
                # ... otherwise, create and check out a new local branch at the tip of the fetched remote branch.
                git checkout -b "${_remote_conf_value__pull__local_branch}" "origin-pull/${_remote_conf_value__pull__remote_branch}"
            fi
        elif
            test "${_remote_conf_value__is_use_git}" = false
        then
            # print yet to be implemented error
            printf "%s\n" "${_t_f_red}Error:${_t_reset} Non git remote support is yet to be implemented." 1>&2
        fi
    done

    # TODO: Install any remotes and groups specified after `install` in the arguments; if none are specified, install any remotes in the default group that are not already installed. If the `u` system was already installed, and either the default group of remotes, or any remotes and groups specified in the arguments were already installed, print a message stating so, and a `did you mean` message suggesting the `pull` command.
    # TODO: Clone remotes in the `default` group.
}

_pull()
{
    # TODO: If there are any remotes that are not installed, ask if the user want to install them, or continue and only pull the already installed remotes. If the user does want to install the missing remotes, install them, remove them from the list of remotes to pull since it's redundant, then pull the already existing remotes, if any.

    # TODO: Handle the `all` and `default` cases.

    _set_remote_names "${@}"

    for \
        _remote_name in $(printf "%s\n" "${_remote_names}")
    do
        _get_remote_conf_values "${_remote_name}" "_remote_conf_value__"

        # TODO
    done
}

_push()
{
    # TODO: Add warning if pushing sensitive files to a remote without `is_encrypted` set to `true` in the config file. Check if a file is sensitive by checking it's permissions (see if there are any drawbacks to this), and/or maybe based on a sensitive file list in the config, possibly located at `${U_DIR}/config/u/sensitive-paths.conf`.

    printf "%s\n" "${_t_f_red}Error:${_t_reset} The \`push\` command is not yet implemented." 1>&2
    return 1

    _set_remote_names "${@}"

    for \
        _remote_name in $(printf "%s\n" "${_remote_names}")
    do
        _get_remote_conf_values "${_remote_name}" "_remote_conf_value__"

        # TODO
    done
}

_remove()
{
    # TODO: Implement removing remotes and groups of remotes.

    # TODO: If there are any remotes that are not installed, ask if the user want to install them, or continue and only pull the already installed remotes. If the user does want to install the missing remotes, install them, remove them from the list of remotes to pull since it's redundant, then pull the already existing remotes, if any.

    if
        test "${#}" -eq 0
    then
        printf "%s\n" \
            "${_t_f_red}WARNING: THIS IS A DESTRUCTIVE ACTION.${_t_reset}" \
            "This will securely delete all files installed or managed by this script." \
            "Ensure you have run \`${_repository_base__script_name} push\` if you wish to keep any changes since installation or the last pull." \
            "Note that any files in \`${U_DIR}/local\` will be lost; they are not tracked as that directory is intended for system-specific overrides." \
            "" \
            "\nType \`CONFIRM\` to continue, or press \`ENTER\` to abort." \
            "" \
            "> "

        read -r _user_input

        if
            test "${_user_input}" = "CONFIRM"
        then
            # TODO: Handle removing lines added to `.bashrc` and `.profile` files.

            # TODO: Handle deleting files elsewhere on the system that were downloaded or cloned based on the information in `.config/u/remotes`, especially sensitive files in the home dir.

            if
                command -v shred > /dev/null 2>&1
            then
                find "${U_DIR}" -type f -exec shred -n 3 -u {} +
            else
                if
                    test -e "/dev/urandom"
                then
                    _dd_if="/dev/urandom"
                else
                    _dd_if="/dev/zero"
                fi

                find "${U_DIR}" -type f \
                | while
                    IFS="" read -r _file
                do
                    # shellcheck disable=SC2034
                    for \
                        i in 1 2 3
                    do
                        dd if="${_dd_if}" of="${_file}" conv=notrunc 2> /dev/null
                    done

                    rm -f "${_file}"
                done
            fi

            export U_DIR=""

            _shell_startup_files_remove_snippet
        else
            printf "\n%s\n" "Aborted." 1>&2

            return 0
        fi
    fi

    _set_remote_names "${@}"

    for \
        _remote_name in $(printf "%s\n" "${_remote_names}")
    do
        _get_remote_conf_values "${_remote_name}" "_remote_conf_value__"

        # TODO
    done
}

if
    test "${#}" -eq 0 \
    || test "${1}" = "help" \
    || test "${1}" = "h" \
    || test "${1}" = "--help" \
    || test "${1}" = "-h"
then
    _print_help
elif
    test "${1}" = "install" \
    || test "${1}" = "i"
then
    shift
    _ensure_git
    _install "${@}"
elif
    test "${1}" = "push"
then
    shift
    _ensure_git
    _push "${@}"
elif
    test "${1}" = "pull"
then
    shift
    _ensure_git
    _pull "${@}"
elif
    test "${1}" = "remove"
then
    shift
    _remove "${@}"
elif
    test "${1}" = "init"
then
    shift
    _ensure_git
    _init "${@}"
fi
