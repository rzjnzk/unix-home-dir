#!/bin/sh
#
# NAME
#     test-colors - test color terminal text attributes and display their `tput` and `ANSI` codes

_sigint()
{
    tput sgr0 2> /dev/null || :
    printf "\033[0m\n"

    exit 130
}

trap _sigint INT || :

# NOTE: `\033` is the 'ASCII escape character'.
# NOTE: `\033[` is the 'Control Sequence Introducer' or 'CSI'.
_csi="$(printf "\033[")"

_reset="$(tput sgr0 2> /dev/null)${_csi}0m"

_tput_colors="$(tput colors 2>&1)"

printf "\n%s\n\n" "\`tput colors\` output: \`${_tput_colors}\`."

if
    ! test "${_tput_colors}" -ge 0 2> /dev/null
then
    _tput_colors=256
fi

_number=0

_print_up_to()
{
    printf "\n\n%s\n\n" "${2}"

    if
        test "${_number}" -ge "${_tput_colors}"
    then
        printf "%s\n" "Palette unsupported."
    fi

    while
        test "${_number}" -lt "${1}" \
        && test "${_number}" -lt "${_tput_colors}"
    do
        # Calculate the ANSI SGR, or Select Graphic Rendition, parameters. 
        if
            test "${_number}" -le 7
        then
            _ansi_fg_sgr_parameter="$(expr 30 + "${_number}")"
            _ansi_bg_sgr_parameter="$(expr 40 + "${_number}")"
        elif
            test "${_number}" -le 15
        then
            _ansi_fg_sgr_parameter="$(expr 90 + "${_number}" - 8)"
            _ansi_bg_sgr_parameter="$(expr 100 + "${_number}" - 8)"
        else
            _ansi_fg_sgr_parameter="38;5;${_number}"
            _ansi_bg_sgr_parameter="48;5;${_number}"
        fi

        # printf "%-22s %-22s %-22s %-22s\n" \
        #     "$(tput setaf "${_number}" 2> /dev/null)tput setaf ${_number}${_reset}" \
        #     "$(tput setab "${_number}" 2> /dev/null) tput setab ${_number} ${_reset}" \
        #     "${_csi}${_ansi_fg_sgr_parameter}m\\033[${_ansi_fg_sgr_parameter}m${_reset}" \
        #     "${_csi}${_ansi_bg_sgr_parameter}m \\033[${_ansi_bg_sgr_parameter}m ${_reset}"
        printf "%s%-14s%s %s%-16s%s %s%-14s%s %s%-16s%s\n" \
            "$(tput setaf "${_number}" 2> /dev/null)" "tput setaf ${_number}" "${_reset}" \
            "$(tput setab "${_number}" 2> /dev/null)" " tput setab ${_number} " "${_reset}" \
            "${_csi}${_ansi_fg_sgr_parameter}m" "\\033[${_ansi_fg_sgr_parameter}m" "${_reset}" \
            "${_csi}${_ansi_bg_sgr_parameter}m" " \\033[${_ansi_bg_sgr_parameter}m " "${_reset}"

        _number="$(expr "${_number}" + 1)"
    done
}

printf "\n%s\n" "AVAILABLE COLORS:"

# 0–7: Standard or basic colors
# 8–15: Bright or high-intensity colors
# 0–15: 16-color palette (standard + bright)
# 16–255: Extended or 256-color palette

_print_up_to 8 "Standard or basic color palette:"
_print_up_to 16 "Bright or high-intensity color palette:"
_print_up_to 256 "Extended color palette:"

# _print_text_attribute_color_range 0 7 "Standard or basic color palette:"
# _print_text_attribute_color_range 8 15 "Bright or high-intensity color palette:"
# _print_text_attribute_color_range 16 255 "Extended color palette:"

printf "\n\nNON-COLOR TERMINAL TEXT ATTRIBUTES:\n\n"

_format="%-14s %s%-16s%s %s%-14s%s\n"

printf "${_format}" \
    "Bold: " \
    "$(tput bold 2>/dev/null)" "tput bold" "${_reset}" \
    "${_csi}1m" "\\033[1m" "${_reset}"

printf "${_format}" \
    "Dim: " \
    "$(tput dim 2>/dev/null)" "tput dim" "${_reset}" \
    "${_csi}2m" "\\033[2m" "${_reset}"

printf "${_format}" \
    "Standout: " \
    "$(tput smso 2>/dev/null)" "tput smso" "${_reset}" \
    "" "" ""

printf "${_format}" \
    "Italics: " \
    "$(tput sitm 2>/dev/null)" "tput sitm" "${_reset}" \
    "${_csi}3m" "\\033[3m" "${_reset}"

printf "${_format}" \
    "Underline: " \
    "$(tput smul 2>/dev/null)" "tput smul" "${_reset}" \
    "${_csi}4m" "\\033[4m" "${_reset}"

printf "${_format}" \
    "Blink: " \
    "$(tput blink 2>/dev/null)" "tput blink" "${_reset}" \
    "${_csi}5m" "\\033[5m" "${_reset}"

printf "${_format}" \
    "Rapid Blink:" \
    "" "" "" \
    "${_csi}6m" "\\033[6m" "${_reset}"

printf "${_format}" \
    "Reverse: " \
    "$(tput rev 2>/dev/null)" "tput rev" "${_reset}" \
    "${_csi}7m" "\\033[7m" "${_reset}"

# Great questions! Here’s a breakdown of what you can test and what you might be missing:

# ---

# ## **1. Terminal Text Attributes**

# You’ve covered most of the common SGR (Select Graphic Rendition) text attributes:

# - Bold (`1`)
# - Dim (`2`)
# - Italic (`3`, not always supported)
# - Underline (`4`)
# - Blink (`5`)
# - Reverse (`7`)
# - Standout (`3` via `smso`, but this is often the same as bold or reverse)

# **Other SGR attributes you could add:**
# - **Double underline** (`21` or `tput smulr` if supported)
# - **Conceal/hidden** (`8`)
# - **Strikethrough** (`9`)
# - **Overline** (`53`)
# - **Fraktur** (`20`)
# - **Superscript/subscript** (`73`/`74`)
# - **Rapid blink** (`6`)

# *Note: Many of these are not widely supported, but you can still test them.*

# ---

# ## **2. Other Terminal Capabilities to Test**

# ### **a. Cursor Movement and Positioning**
# - Move the cursor to a specific position (`tput cup`)
# - Save and restore cursor position (`tput sc` and `tput rc`)
# - Show/hide cursor (`tput civis` and `tput cnorm`)

# ### **b. Screen Manipulation**
# - Clear screen (`tput clear`)
# - Clear to end of line (`tput el`)
# - Clear to end of screen (`tput ed`)
# - Scroll up/down (`tput ind`/`tput ri`)

# ### **c. Terminal Size**
# - Get terminal rows/columns (`tput lines`, `tput cols`)

# ### **d. Alternate Screen Buffer**
# - Switch to alternate screen (`tput smcup`), return (`tput rmcup`)
# - Used by full-screen apps like `less`, `vim`, etc.

# ### **e. Input Capabilities**
# - Test for function keys, arrow keys, etc. (more advanced, but possible)

# ### **f. Unicode and Character Support**
# - Print Unicode characters, box-drawing, emoji, etc.

# ### **g. Mouse Support**
# - Enable mouse reporting (advanced, but possible with escape codes)

# ---

# ## **3. Testing Redraw/Scrolling/Full-Screen Capabilities**

# You can test:
# - If the terminal supports rewriting squares (by moving the cursor and overwriting text)
# - If alternate screen buffer is supported (like in `less`, `vim`)
# - If the terminal supports smooth scrolling or partial redraws

# ---

# ## **4. Example: Testing Cursor Movement and Screen Manipulation**

# Add a section like this to your script:

# ```sh
# printf "\nCURSOR MOVEMENT AND SCREEN MANIPULATION:\n\n"

# printf "Moving cursor to row 5, col 10: "
# tput cup 5 10
# echo "Here!"

# sleep 1

# printf "Saving cursor position, moving, and restoring...\n"
# tput sc
# tput cup 10 20
# echo "Moved!"
# sleep 1
# tput rc
# echo "Back!"

# printf "Clearing to end of line: "
# echo -n "This will be cleared"
# tput el
# echo

# printf "Clearing screen in 1 second...\n"
# sleep 1
# tput clear
# ```

# ---

# ## **5. Summary Table**

# | Capability                  | How to Test (tput/ANSI)         |
# |-----------------------------|----------------------------------|
# | Text attributes             | Already in your script           |
# | Double underline, conceal   | Add SGR 21, 8, etc.              |
# | Cursor movement             | `tput cup`, `tput sc`, `tput rc` |
# | Screen clear/erase          | `tput clear`, `tput el`, `tput ed`|
# | Terminal size               | `tput lines`, `tput cols`        |
# | Alternate screen            | `tput smcup`, `tput rmcup`       |
# | Unicode/emoji               | Print Unicode chars              |
# | Mouse support               | Advanced, via escape codes       |

# ---

# ## **6. Final Thoughts**

# - You have **not exhausted** all terminal capabilities—there’s much more to explore!
# - You can add sections to your script for each capability you want to test.
# - For full-screen/scrolling, try using `tput smcup`/`rmcup` and cursor movement to draw and erase blocks.

# ---

# **Let me know if you want code examples for any specific capability!**